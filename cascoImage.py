# -*- coding: utf-8 -*-
"""Casco.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lc143a2R4knBq40FlbOXKECbZRa8M4oi
"""

import os
import sys
import numpy as np
import skimage.draw
import random
from skimage.measure import find_contours
import matplotlib.pyplot as plt
from matplotlib import patches,  lines
from matplotlib.patches import Polygon
import colorsys



from mrcnn import visualize
from mrcnn.config import Config
from mrcnn import model as modellib


import argparse

# Parse command line arguments
parser = argparse.ArgumentParser(
    description='Test Mask R-CNN to detect cascos.')
parser.add_argument("command",
    metavar="<command>",
    help="'train' or 'test'")
parser.add_argument('--weights', required=True,
    metavar="/path/to/weights.h5",
    help="Path to weights .h5 file or 'coco'")
parser.add_argument('--classes', required=True,
    metavar="/path/to/classes.h5",
    help="Path to classes .txt file")
parser.add_argument('--images', required=False,
    metavar="path or URL to images",
    help='Images to apply on test section')
parser.add_argument('--display', required=False,
    metavar="all or just a random image",
    help='Display image')
parser.add_argument('--output', required=True,
    metavar="path or URL to save video result",
    help='Image to apply on test section')
        
args = parser.parse_args()

weights_path = ""
classes_path = ""
images_path = ""
display_state = ""
output_path = ""
is_mask_rcnn_coco = False

if (args.weights == None):
    print("Weights: None  len_Weights: None")
else:
    weights_path = args.weights
    print("Weights: ", weights_path, " len_Weights: ", len(weights_path))

if (args.images == None):
    print("Images: None  len_Images: None")
else:
    images_path = args.images
    print("Images: ", images_path, " len_Images: ", len(images_path))

if (args.display == None):
    print("Display: None  len_Display: None")
else:
    display_state = args.display
    print("Display: ", display_state, " len_Display: ", len(display_state))

if (args.output == None):
    print("Output: None  len_Output: None")
else:
    output_path = args.output
    print("Output: ", output_path, " len_Output: ", len(output_path))

if (args.classes == None):
    print("Classes: None  len_Classes: None")
else:
    classes_path = args.classes
    print("Classes: ", classes_path, " len_Classes: ", len(classes_path))

ROOT_DIR = os.path.abspath("./")

print(" ################ (INICIO) ROOT_DIR ################")
print(ROOT_DIR)
print(" ################ (FIN) ROOT_DIR ################")

model_filename = os.path.join(ROOT_DIR, weights_path)
class_names_path = os.path.join(ROOT_DIR, classes_path)

# empty list
class_names = []
concat = ""
string = ""
nameConfig = ""
contClasses = 0
cont = 0


with open(class_names_path) as f:

    for line in f:
        string = str(line)
        string = string.rstrip()
        print("(",string,")")
        class_names.append(string)

        
        if (concat == ""):
            if(string != "BG"):
                concat = "'" + string + "'"
                contClasses += 1
                cont += 1
        else:
            concat = concat + "," + "'" + string + "'"
            contClasses += 1
            cont += 1
        
        if(cont == 20):
            concat = concat + "\n"
            cont = 0


            

nameConfig = concat

print(" ################ (INICIO) class_names ################")
print("txt_file Type: ",type(class_names))
print("content: ", class_names)
print("concat content: ", nameConfig)
print("total classes: ", contClasses)
print("")
print(" ################ (FIN) class_names ################")

#exit()
#real_test_dir = 'dataset/casco/val/'
real_test_dir = os.path.join(ROOT_DIR, images_path)
output_name = output_path

#model_filename = "mask_rcnn_casco_0010.h5"
#class_names = ['BG', 'casco']
#real_test_dir = 'C://My Proyects//Mask_RCNN//Mask_RCNN//larvaim//val//'
#output_name = 'result/result_image.png'



min_confidence = 0.6

class CocoConfig(Config):
    """Configuration for training on MS COCO.
    Derives from the base Config class and overrides values specific
    to the COCO dataset.
    """
    # Give the configuration a recognizable name
    NAME = "coco"

    # We use a GPU with 12GB memory, which can fit two images.
    # Adjust down if you use a smaller GPU.
    IMAGES_PER_GPU = 2

    # Uncomment to train on 8 GPUs (default is 1)
    # GPU_COUNT = 8

    # Number of classes (including background)
    NUM_CLASSES = 1 + 80  # COCO has 80 classes


class CascoConfig(Config):
    """Configuration for training on the helmet  dataset.
    """
    # Give the configuration a recognizable name
    NAME = "object"

    # Train on 1 GPU and 1 image per GPU. Batch size is 1 (GPUs * images/GPU).
    GPU_COUNT = 1

    # We use a GPU with 12GB memory, which can fit two images.
    # Adjust down if you use a smaller GPU.
    IMAGES_PER_GPU = 1

    # Number of classes (including background)
    NUM_CLASSES = 1 + contClasses  # background + classes_num (objects)

    # All of our training images are 512x512
    IMAGE_MIN_DIM = 512
    IMAGE_MAX_DIM = 512

    # You can experiment with this number to see if it improves training
    STEPS_PER_EPOCH = 500

    # This is how often validation is run. If you are using too much hard drive space
    # on saved models (in the MODEL_DIR), try making this value larger.
    VALIDATION_STEPS = 5
    
    # Matterport originally used resnet101, but I downsized to fit it on my graphics card
    BACKBONE = 'resnet50'

    # To be honest, I haven't taken the time to figure out what these do
    RPN_ANCHOR_SCALES = (8, 16, 32, 64, 128)
    TRAIN_ROIS_PER_IMAGE = 32
    MAX_GT_INSTANCES = 50 
    POST_NMS_ROIS_INFERENCE = 500 
    POST_NMS_ROIS_TRAINING = 1000 


class InferenceConfigCoco(CocoConfig):
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1
    #IMAGE_MIN_DIM = 512
    #IMAGE_MAX_DIM = 512
    DETECTION_MIN_CONFIDENCE = 0

class InferenceConfig(CascoConfig):
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1
    #IMAGE_MIN_DIM = 512
    #IMAGE_MAX_DIM = 512
    DETECTION_MIN_CONFIDENCE = min_confidence

if weights_path == "coco.h5":

    config = InferenceConfigCoco()
    config.display()
    inference_config = InferenceConfigCoco()
else:
    config = CascoConfig()
    config.display()
    inference_config = InferenceConfig()
    



# Recreate the model in inference mode
model = modellib.MaskRCNN(mode="inference", config=inference_config,  model_dir='logs')

# Get path to saved weights
model_path = model_filename
#model_path = model.find_last()


# Either set a specific path or find last trained weights
# Load trained weights (fill in path to trained weights here)

assert model_path != "", "Provide path to trained weights"
print("Loading weights from ", model_path)



if weights_path == "coco.h5":
    # Download weights file
    #if not os.path.exists(weights_path):
    
    #   utils.download_trained_weights(weights_path)
    # Exclude the last layers because they require a matching
    # number of classes
    model.load_weights(model_path, by_name=True)
else:
    model.load_weights(model_path, by_name=True)
    
def random_colors(N, bright=True):
    """
    Generate random colors.
    To get visually distinct colors, generate them in HSV space then
    convert to RGB.
    """
    brightness = 1.0 if bright else 0.7
    hsv = [(i / N, 1, brightness) for i in range(N)]
    colors = list(map(lambda c: colorsys.hsv_to_rgb(*c), hsv))
    random.shuffle(colors)
    return colors


def apply_mask(image, mask, color, alpha=0.5):
    """Apply the given mask to the image.
    """
    for c in range(3):
        image[:, :, c] = np.where(mask == 1,
                                  image[:, :, c] *
                                  (1 - alpha) + alpha * color[c] * 255,
                                  image[:, :, c])
    return image

def display_instances(image, boxes, masks, class_ids, class_names,
                      scores=None, title="",
                      figsize=(16, 16), ax=None,
                      show_mask=True, show_bbox=True,
                      colors=None, captions=None, output=None):
    """
    boxes: [num_instance, (y1, x1, y2, x2, class_id)] in image coordinates.
    masks: [height, width, num_instances]
    class_ids: [num_instances]
    class_names: list of class names of the dataset
    scores: (optional) confidence scores for each box
    title: (optional) Figure title
    show_mask, show_bbox: To show masks and bounding boxes or not
    figsize: (optional) the size of the image
    colors: (optional) An array or colors to use with each object
    captions: (optional) A list of strings to use as captions for each object
    """
    # Number of instances
    N = boxes.shape[0]
    if not N:
        print("\n*** No instances to display *** \n")
    else:
        assert boxes.shape[0] == masks.shape[-1] == class_ids.shape[0]

    # If no axis is passed, create one and automatically call show()
    auto_show = False
    if not ax:
        _, ax = plt.subplots(1, figsize=figsize)
        auto_show = True

    # Generate random colors
    colors = colors or random_colors(N)

    # Show area outside image boundaries.
    height, width = image.shape[:2]
    ax.set_ylim(height + 10, -10)
    ax.set_xlim(-10, width + 10)
    ax.axis('on')
    ax.set_title(title, loc='center', fontdict={'fontsize': 10, 'fontweight': 20})
    plt.subplots_adjust(bottom=0.1)
    plt.subplots_adjust(top=0.89)

    masked_image = image.astype(np.uint32).copy()
    for i in range(N):
        color = colors[i]

        # Bounding box
        if not np.any(boxes[i]):
            # Skip this instance. Has no bbox. Likely lost in image cropping.
            continue
        y1, x1, y2, x2 = boxes[i]
        if show_bbox:
            p = patches.Rectangle((x1, y1), x2 - x1, y2 - y1, linewidth=2,
                                alpha=0.7, linestyle="dashed",
                                edgecolor=color, facecolor='none')
            ax.add_patch(p)

        # Label
        if not captions:
            class_id = class_ids[i]
            score = scores[i] if scores is not None else None
            label = class_names[class_id]
            caption = "{} {:.3f}".format(label, score) if score else label
        else:
            caption = captions[i]
        ax.text(x1, y1, caption,
                color='w', size=11, backgroundcolor="none")

        # Mask
        mask = masks[:, :, i]
        if show_mask:
            masked_image = apply_mask(masked_image, mask, color)

        # Mask Polygon
        # Pad to ensure proper polygons for masks that touch image edges.
        padded_mask = np.zeros(
            (mask.shape[0] + 2, mask.shape[1] + 2), dtype=np.uint8)
        padded_mask[1:-1, 1:-1] = mask
        contours = find_contours(padded_mask, 0.5)
        for verts in contours:
            # Subtract the padding and flip (y, x) to (x, y)
            verts = np.fliplr(verts) - 1
            p = Polygon(verts, facecolor="none", edgecolor=color)
            ax.add_patch(p)
    ax.imshow(masked_image.astype(np.uint8))

    #save result image
    plt.savefig(output)
    
    if auto_show:
        plt.show()

import skimage

image_paths = []

if display_state == "all":
    for filename in os.listdir(real_test_dir):
        if os.path.splitext(filename)[1].lower() in ['.png', '.jpg', '.jpeg']:
            image_paths.append(os.path.join(real_test_dir, filename))

    for image_path in image_paths:
        img = skimage.io.imread(image_path)
        img_arr = np.array(img)
        results = model.detect([img_arr], verbose=1)
        r = results[0]
        display_instances(img, r['rois'], r['masks'], r['class_ids'], 
                                    class_names, r['scores'], title=nameConfig, figsize=(16,16), output=output_name)
        
else:
    # Load a random image from the images folder
    
    file_names = next(os.walk(real_test_dir))[2]
    #if os.path.splitext(real_test_dir)[1].lower() in ['.png', '.jpg', '.jpeg']:
    random_image = random.choice(file_names)

    if os.path.splitext(random_image)[1].lower() in ['.png', '.jpg', '.jpeg']:
        random_image = random.choice(file_names)

        img = skimage.io.imread(os.path.join(real_test_dir, random_image))
            
        #img = skimage.io.imread(real_test_dir)
        img_arr = np.array(img)
        results = model.detect([img_arr], verbose=1)
        r = results[0]
        display_instances(img, r['rois'], r['masks'], r['class_ids'], 
                                        class_names, r['scores'], title=nameConfig, figsize=(16,16), output=output_name)
        is_image = True
                                        
    else:
        is_image = False

        
    while is_image == True:
        #random_image = random.choice(file_names)
        if is_image == True:
            random_image = random_image
        else:
            random_image = random.choice(file_names)

        if random_image != "via_region_data.json":
            random_image = random.choice(file_names)

            img = skimage.io.imread(os.path.join(real_test_dir, random_image))
            
            #img = skimage.io.imread(real_test_dir)
            img_arr = np.array(img)
            results = model.detect([img_arr], verbose=1)
            r = results[0]
            display_instances(img, r['rois'], r['masks'], r['class_ids'], 
                                            class_names, r['scores'], title=nameConfig, figsize=(16,16), output=output_name)
            is_image = True
            print("############## Es una imagen ##############")
            break
            
        else:
            random_image = random.choice(file_names)
            is_image = False
            print("############## NO Es una imagen ##############")
        